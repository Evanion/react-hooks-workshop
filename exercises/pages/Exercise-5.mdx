---
name: Ex. 5 - Error Handling
order: 5
---

# Ex. 5 - Error Handling

## Instructions

Actuellement notre application ne gère pas les cas d'erreur. Lorsque l'on utilise une API externe, on ne la maîtrise pas et il faut toujours s'attendre à avoir des erreurs.

Nous allons utiliser les [Error Boundaries](https://reactjs.org/docs/error-boundaries.html), avec cette technique, nous serons à la fois tolérants aux erreurs issues de l'API mais aussi à celles issues de notre propre code.

- Créer une `ErrorBoundary` simple dans `src/components/Catch.js`
- Englober toute l'application avec le composant `Catch` dans `index.js`
- Modifier le Hook custom `useMovieSearch` pour emettre une erreur lorsque la requête échoue

### Résultat attendu

Lorsque le champs de recherche est vide, j'ai un message d'erreur.

<iframe
  src="https://codesandbox.io/embed/github/smooth-code/react-hooks-workshop/tree/end-exercise-5/?fontsize=14&view=preview"
  style={{
    width: '100%',
    height: 500,
    border: 0,
    borderRadius: 4,
    overflow: 'hidden',
  }}
  sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"
/>

## Aide

### Error Boundary : implémentation

```js
import React, { Component } from 'react'

export default class Catch extends Component {
  state = { hasError: false }

  static getDerivedStateFromError(error) {
    // Mise à jour du state, au prochain rendu, nous saurons qu'une erreur a été catchée
    return { hasError: true }
  }

  render() {
    if (this.state.hasError) {
      // Affichage du fallback de notre choix
      return <h1>Something went wrong.</h1>
    }

    return this.props.children
  }
}
```

### Error Boundary : utilisation

```js
ReactDOM.render(
  <Catch>
    <App />
  </Catch>,
  document.getElementById('root'),
)
```

### Stratégie pour `throw`

```js
import { useState, useEffect } from 'react'

function useApi() {
  // State contenant le résultat
  const [state, setState] = useState({ result: null, error: null })

  useEffect(() => {
    request()
      // Lorsque tout se passe bien, j'obtiens un résultat
      .then(result => setState({ result, error: null }))
      // En cas d'erreur, le catch est appelé
      .catch(error => setState({ error, result: null }))
  })

  // Si une erreur a été retournée par la requête, alors je throw
  if (state.error) {
    throw state.error
  }

  return state.result
}
```
